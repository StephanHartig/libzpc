<?xml version="1.0" encoding="UTF-8"?>
<!--Arbortext, Inc., 1988-2011, v.4002-->
<!DOCTYPE concept PUBLIC "-//IBM//DTD DITA IBM Concept//EN"
 "ibm-concept.dtd">
<?Pub Sty _display FontColor="red"?>
<concept id="lxpc_lifecycle" xml:lang="en-us">
<title>Lifecycle of key objects</title>
<titlealts>
<navtitle>Lifecycle</navtitle>
<searchtitle><ph conref="lxcommon.dita#phrases/lib_title"/>: Lifecycle of key objects in <keyword
conref="lxpc_conref.dita#lxpc_conref/libzpc"/></searchtitle>
</titlealts>
<shortdesc>Read information about the structure of an application exploiting <keyword
conref="lxpc_conref.dita#lxpc_conref/libzpc"/> APIs and how the lifecycle of generated key objects
is controlled. </shortdesc>
<prolog>
<metadata>
<keywords>
<indexterm>lifecycle of key objects</indexterm>
<indexterm>key objects<indexterm>lifecycle</indexterm></indexterm>
</keywords>
</metadata>
</prolog>
<conbody>
<section><title>Deciding how to generate a protected key</title><p>In your application program, you
normally start with using a function to allocate an empty container for an <keyword
conref="lxpc_conref.dita#lxpc_conref/aeskeyobj"/>. For this purpose, use function
<apiname>zpc_aes_key_alloc()</apiname> as described in <xref href="lxpc_apis_key.dita"/>. Then you
continue to fill the container by setting desired key attributes by using functions like <apiname>
zpc_aes_key_set_size()</apiname>, <apiname> zpc_aes_key_set_type()</apiname>, or <apiname>
zpc_aes_key_set_apqns()</apiname>. The key size must always be set before generating a protected key.
</p>
<p rev="v1i1">To generate a protected key, you normally use function
<apiname>zpc_aes_key_generate()</apiname> (<xref href="lxpc_apis_key.dita#lxpc_apis_key_object/key_generate"/>). 
You can distinguish the following use cases:
</p>
<p rev="v1i1">If you use this function, and no attributes are specified besides the
key size, a random volatile protected key is generated on the <keyword
conref="lxpc_conref.dita#lxpc_conref/cpacf"/>. You can use such volatile protected keys in use cases
within the lifetime of an LPAR or virtual guest, for example, for encrypting swap disks. 
</p>
<p rev="v1i1">If you want to make permanent use of protected-key cryptography across the lifetime of
an LPAR, KVM virtual server, or <ph conref="lxcommon.dita#phrases/ph_vm"/> guest virtual machine,
you use this function to generate a secure key/protected key pair. In this case, further attributes
must be known to the application before key pair generation, for example, to decide whether a CCA
AES DATA secure key should be generated on a <keyword
conref="lxpc_conref.dita#lxpc_conref/cryptocoproc"/> and on which APQNs the key pair generation
should happen. The function then generates a secure key with the specified attributes, unwraps the
secure key's effective key and re-wraps the effective key with the wrapping key generated by the
firmware. The result is a protected key with the same effective key as wrapped in the secure key.  A
new protected key is automatically derived from the secure key using a new firmware wrapping key
when required. This happens in cases where for example an LPAR has been rebooted in the meanwhile
and thus the old firmware wrapping key is no longer available.</p>
<p rev="v1i1">If you decide to generate a secure key/protected
key pair you can select from two ways how to associate the secure key to certain APQNs:</p><ul>
<li>You can directly specify the APQNs before generating the key by using the <apiname>
zpc_aes_key_set_apqns()</apiname> function.</li>
<li>You can have <keyword conref="lxpc_conref.dita#lxpc_conref/libzpc"/> retrieve the appropriate
APQNs from a given master key verification pattern by using the
<apiname>zpc_aes_key_set_mkvp()</apiname> function.</li>
</ul><note>If you use both methods in your application, the second invocation overwrites the first
one. </note><p>After specifying the attributes, you can select from several APIs to generate or
import a key into this container. To generate a new random protected key or a secure key/protected
key pair, use function <apiname>zpc_aes_key_generate()</apiname>. You can also import either a clear
key which is wrapped by the master key to become a secure key which in turn is transformed into a
protected key. This is achieved by function <apiname>zpc_aes_key_import_clear()</apiname>. Or you
can directly import an existing secure key for transformation into a protected key with function
<apiname>zpc_aes_key_import()</apiname>. For more information, see <xref href="lxpc_apis_key.dita"
/>.</p></section>
<section>
<title>Using and managing keys with a reference count</title>
<p>The functions of the <keyword conref="lxpc_conref.dita#lxpc_conref/libzpc"/> library care for the
lifetime of your key object. When allocating a key object, an internal reference count is set to 1
to indicate that the key is in use. </p>
<p>Now you can use this key to perform your required cryptographic operations using the appropriate
functions from the library. Each cryptographic operation that uses this key, increments this
reference count at the beginning and decreases it after successful processing. This ensures that the
reference count is always at least greater than zero as long as the <keyword
conref="lxpc_conref.dita#lxpc_conref/aeskeyobj"/> is in use by any operation.</p>
<p>Finally, you use function <apiname>zpc_aes_key_free()</apiname> to free the space for the key
object. This function decrements the reference count by 1 and frees it only if the count reaches 0.
This function can run before the last cryptographic operation finishes, because in this case the
reference count is not yet zero, due to the incrementation by the running operation. Each operation
checks the reference count when finishing and frees the key object if the count reaches 0. </p>
</section>
<section>
<title>Reuse of an AES key object context</title>
<p> You can reuse the context (that is, the container) for generating a new key of the same type.
For keys with an initialization vector, you set a new vector to overwrite the old one. The reference
count of the old key is decremented by one, and incremented by one for the new key.</p>
</section>
</conbody>
</concept>
<?Pub *0000003393?>
